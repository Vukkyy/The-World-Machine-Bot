from interactions import *
from uuid import uuid4
import validators
import re
import base64
import bot_data.generate_text as generate_text
import random
import asyncio
import bot_data.database_manager as db
import json

from bot_data.error_handler import on_error
from bot_data.embed_gen import fancy_send

class BATTLES(Extension):
    @extension_command(description = 'Generate Epic battles!')
    async def battles(self, ctx):
        pass
    
    def __init__(self, client):
        self.client = client
        with open('databases/battles.db', 'w') as f:
            f.write(json.dumps({'uid': 0, 'battle_list':[], 'name_list':[], 'battling': False}))
            
    @battles.subcommand(description='Convert old BCLs to the new format.')
    @option(description='The BCL to convert to the new format.', required=True)
    async def convert_bcl(self, ctx : CommandContext, old_bcl : str = ''):
        bcl_data = old_bcl.split('>')
        bcl_data[1] = 'Physical'
        bcl = '►'.join(bcl_data)
        
        encode = bcl.encode('utf-8')
        base64_ = base64.b64encode(encode)
        decoded_bcl = base64_.decode('utf-8')
        
        await fancy_send(ctx, f'[ Here is your new converted BCL string. ] ```{decoded_bcl}```', ephemeral=True)
    
    @battles.subcommand(description='Start up a battle generated by GPT-3.')
    @option(description='Set how long the delays are between battles. By default it is set to 20 seconds.', min_value = 2, max_value = 100)
    async def setup(self, ctx : CommandContext, delay : int = 20):
        
        if not Permissions.MANAGE_CHANNELS in ctx.author.permissions:
            await fancy_send(ctx, 'Sorry! But you need the ``MANAGE_CHANNELS`` permission in this server to setup a tournament!', ephemeral = True, color = 0xff171d)
            return
        
        with open('databases/battles.db', 'r') as f:
            l = f.read().split('\n')
            i = []
            
            for item in l:
                i.append(json.loads(item))
                
            for item in i:
                if item['uid'] == int(ctx.guild_id):
                    if item['battling'] == True:
                        await fancy_send(ctx, 'This server already has a battle being set up!', ephemeral = True, color = 0xff171d)
                        return
        
        uid = uuid4()
        
        embed = Embed(
            title = 'A battle is about to commence!',
            color=0x933397
        )
        
        embed.add_field(
            name = 'How to add fighters?',
            value = 'Adding fighters is simple, click on \'Create Fighter\' to create a fighter, or import a BCL string.',
            inline=True
        )
        
        embed.add_field(
            name = 'Current Roster',
            value = 'There are no fighters in this tournament!',
            inline=True
        )
        
        buttons = [
            Button(style=ButtonStyle.SUCCESS, label='Create Fighter', custom_id=f'create {uid}'),
            Button(style=ButtonStyle.PRIMARY, label='Import from BCL', custom_id=f'import {uid}'),
        ]
        
        admin_buttons = [
            Button(style=ButtonStyle.SECONDARY, label='Remove Fighter', custom_id=f'delete {uid}', disabled=True),
            Button(style=ButtonStyle.DANGER, label='Start Tournament', custom_id=f'start {uid}', disabled=True),
            Button(style=ButtonStyle.PRIMARY, label='Export Roster', custom_id=f'export {uid}'),
            Button(style=ButtonStyle.SECONDARY, label='Cancel', custom_id=f'cancel {uid}')
        ]
        
        action_row = ActionRow(
            components=buttons
        )
        
        action_row2 = ActionRow(
            components=admin_buttons
        )
        
        msg = await ctx.send(embeds=embed, components=[action_row, action_row2])
        
        battle_list = []
        name_list = []
        
        current_battle_list = []
        
        while True:
            
            task = asyncio.create_task(self.client.wait_for_component(components=[action_row, action_row2]))
            while True:
                done, pending = await asyncio.wait({task}, timeout=1)
                
                if not done:
                    db_ = await db.GetDatabase(int(ctx.guild_id), 'battles', {'uid':int(ctx.guild_id), 'battle_list':[], 'name_list':[], 'battling': True})
                    await db.SetDatabase(int(ctx.guild_id), 'battles', 'battling', True)
                    
                    name_list = db_['name_list']
                    battle_list = db_['battle_list']
                    
                    if len(current_battle_list) != len(battle_list):
                        current_battle_list = battle_list
                    
                        current_embed: Embed = msg.embeds[0]
                
                        if len(name_list) % 2 == 0:
                            admin_buttons[1].disabled = False
                        if not len(name_list) == 0:
                            current_embed.fields[1].value = '\n'.join(name_list)
                            admin_buttons[0].disabled = False
                        else:
                            current_embed.fields[1].value = 'There are no fighters in this tournament!'
                            admin_buttons[1].disabled = True
                            admin_buttons[0].disabled = True

                        await msg.edit(embeds=current_embed, components=[action_row, action_row2])
                    continue
                
                break
                
            button_ctx = task.result()
    
            data = button_ctx.data.custom_id
            
            if data == f'create {uid}':
                modal = Modal(
                custom_id='battle',
                title = 'Generate a Battle Contestant',
                components=[
                    TextInput(
                        style = TextStyleType.SHORT,
                        custom_id='name',
                        label='Name',
                        placeholder='What is their name?',
                        required=True
                    ),
                    TextInput(
                        style = TextStyleType.SHORT,
                        custom_id=f'weapontype {uid}',
                        label='Weapon Type',
                        placeholder='Type either Magical, Physical or Tool.',
                        required=True
                    ),
                    
                    TextInput(
                        style = TextStyleType.SHORT,
                        custom_id='weapon',
                        label='Weapon Name',
                        placeholder='What is their weapon called?',
                        required=True
                    ),
                    TextInput(
                        style = TextStyleType.PARAGRAPH,
                        custom_id='description',
                        label='Personality',
                        placeholder='Write a description of your fighter\'s personality, be sure to list pronouns.',
                        required=True
                    ),
                    TextInput(
                        style = TextStyleType.SHORT,
                        custom_id='url',
                        label='Image URL',
                        placeholder='https://image/my_image.png',
                        required=True
                    )
                    ]
                )
                
                await button_ctx.popup(modal)

            if data == f'import {uid}':
                modal = Modal(
                    custom_id='bcl',
                    title='Import from BCL',
                    components=[
                        TextInput(style=TextStyleType.PARAGRAPH, custom_id='sus', label='BCL', placeholder='Input BCL data here. You can add more fighters by putting a \',\' between each BCL.')
                    ]
                )
                
                await button_ctx.popup(modal)                    
            
            if data == f'delete {uid}':
                
                choices = []
                
                i = 0
                for name in name_list:
                    choices.append(SelectOption(label=name, value = i))
                    i += 1
                    
                menu = SelectMenu(
                    custom_id=f'menuBattle',
                    options=choices,
                    placeholder='Select a fighter to remove.'
                )
                
                can_pass = True
                
                if not Permissions.MANAGE_CHANNELS in button_ctx.author.permissions:
                    await fancy_send(button_ctx, 'Sorry! But you need the ``MANAGE_CHANNELS`` permission in this server to remove a fighter!', ephemeral = True, color = 0xff171d)
                    can_pass = False
                
                if can_pass:
                    await fancy_send(button_ctx, '', components = menu, ephemeral=True)
                    
            if data == f'start {uid}':
                
                can_pass = True
                
                if not Permissions.MANAGE_CHANNELS in button_ctx.author.permissions:
                    await fancy_send(button_ctx, 'Sorry! But you need the ``MANAGE_CHANNELS`` permission in this server to start a tournament!', ephemeral = True, color = 0xff171d)
                    can_pass = False
                
                battles = []
                
                random.shuffle(battle_list)

                if can_pass:
                    i = 1
                    for contestant in battle_list:
                        if i % 2 == 0:
                            battles.append([battle_list[i - 2], battle_list[i - 1]])
                            
                        i += 1
                        
                    await msg.edit(embeds=current_embed, components=[])
                    
                    b_index = 0
                    
                    while len(battle_list) > 1:
                        if not b_index == 0:
                            await ctx.chanfancy_send(ctx, '**Starting Next Round!**')
                            battles = []
                            
                            i = 1
                            for contestant in battle_list:
                                if i % 2 == 0:
                                    battles.append([battle_list[i - 2], battle_list[i - 1]])
                                i += 1
                            
                        index = 0
                        
                        for battle in battles:
                            
                            c_one = battle[0].split('►')
                            c_two = battle[1].split('►')
                            btl = await ctx.chanfancy_send(ctx, f"**A battle begins! {c_one[0]} versus {c_two[0]}!**")
                            
                            btl1 = await btl.reply('Generating battle... <a:loading:1026539890382483576>')
                            
                            num = random.randint(0, 1)
            
                            winner = None
                            
                            if num == 0:
                                winner = c_one
                                del name_list[battle_list.index(battle[1])]
                                battle_list.remove(battle[1])
                            else:
                                winner = c_two
                                del name_list[battle_list.index(battle[0])]
                                battle_list.remove(battle[0])
                            
                            final_round = False
                            
                            if len(battle_list) == 1:
                                final_round = True
                            
                            
                            text = await generate_text.GenerateBattle(c_one[1], c_one[0], c_one[2], c_one[3], c_two[1], c_two[0], c_two[2], c_two[3], winner[0], final_round)
                            
                            embed = Embed(
                                title = f'{c_one[0]} versus {c_two[0]}',
                                description = text,
                                color=0x7d00b8
                            )
                            
                            result = await btl1.edit(content = '', embeds=embed)
                            
                            index += 1
                            
                            if len(battle_list) == 1:
                                
                                await db.SetDatabase(int(button_ctx.guild_id), 'battles', 'battling', False)
                                
                                result_embed = Embed(
                                        title = f'{winner[0]} is the winner of the tournament!',
                                        description='Congrats!',
                                        thumbnail=EmbedImageStruct(url=winner[4]),
                                        color=0x7d00b8
                                    )
                                
                                await result.reply(embeds=result_embed)
                                return
                            
                            if index == len(battles):
                                
                                print(len(battle_list))
                                
                                result_embed = Embed(
                                        title = f'{winner[0]} is the winner of this round!',
                                        description=f'The next round will begin in {delay} seconds!',
                                        thumbnail=EmbedImageStruct(url=winner[4]),
                                        color=0x7d00b8
                                    )
                            
                            else:
                                result_embed = Embed(
                                    title = f'{winner[0]} is the winner!',
                                    thumbnail=EmbedImageStruct(url=winner[4]),
                                    description=f'The next battle will begin in {delay} seconds!',
                                    color=0x7d00b8
                                )
                            
                            await result.reply(embeds=result_embed)
                            
                            await asyncio.sleep(delay)
                            
                        b_index += 1
                        
            if (data == f'cancel {uid}'):
                can_pass = True
                
                if not Permissions.MANAGE_CHANNELS in button_ctx.author.permissions:
                    await fancy_send(button_ctx, '[ Sorry! But you need the ``MANAGE_CHANNELS`` permission in this server to remove a fighter! ]', ephemeral = True, color = 0xff171d)
                    can_pass = False
                
                if can_pass:
                    await msg.delete()
                    await fancy_send(button_ctx, f'<@{button_ctx.author.id}> Cancelled the Tournament.')
                    await db.SetDatabase(int(button_ctx.guild_id), 'battles', 'battling', False)
                    return
                
            if data == f'export {uid}':
                
                bcl_list = []
                
                for bcl in battle_list:
                    encode = bcl.encode('utf-8')
                    base64_ = base64.b64encode(encode)
                    bcl_list.append(base64_.decode('utf-8'))
                
                bcl_string = ','.join(bcl_list)
                
                await fancy_send(button_ctx, f'[ Here is the exported roster. Use "Import from BCL" to load the roster again. ] ```{bcl_string}```')
                    
                    
                        
    @extension_modal('battle')
    async def create_fighter(self, modal_ctx : CommandContext, name, type, weapon, description, url):
        can_pass = True
        
        values = [name, type, weapon, description, url]
        
        db_ = await db.GetDatabase(int(modal_ctx.guild_id), 'battles', {'uid':int(modal_ctx.guild_id), 'battle_list':[], 'name_list':[], 'battling': False})
        
        battle_list = db_['battle_list']
        name_list = db_['name_list']
                    
        if not validators.url(values[4]):
            await fancy_send(modal_ctx, '[ You need to put in a valid Image URL. ]', ephemeral = True, color = 0xff171d)
            can_pass = False
        
        if values[1].lower() == 'magical':
            pass
        elif values[1].lower() == 'physical':
            pass
        elif values[1].lower() == 'tool':
            pass
        else:
            await fancy_send(modal_ctx, f'[ You need to type either Magical, Physical or Tool for the weapon type. ]', ephemeral = True, color = 0xff171d)
            can_pass = False
            
        if values[0] in name_list:
            await fancy_send(modal_ctx, f'[ It seems as though ``{values[0]}`` is already a fighter in this tournament. ]', ephemeral = True, color = 0xff171d)
            can_pass = False
        
        if can_pass:
            bcl = f'{values[0]}►{values[1]}►{values[2]}►{values[3]}►{values[4]}'
            
            battle_list.append(bcl)
            name_list.append(values[0])
            
            encode = bcl.encode('utf-8')
            base64_ = base64.b64encode(encode)
            decoded_bcl = base64_.decode('utf-8')
            
            await fancy_send(modal_ctx, f'<@{modal_ctx.author.id}> added ``{values[0]}`` to the roster.')
            await fancy_send(modal_ctx, f'Successfully created ``{values[0]}``. To use this fighter in the future, please save this BCL: ```{decoded_bcl}```', ephemeral=True)
            
            await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'battle_list', battle_list)
            await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'name_list', name_list)
    
    @extension_modal('bcl')
    async def bcl(self, modal_ctx, bcl):
        
        values = [bcl]
        
        db_ = await db.GetDatabase(int(modal_ctx.guild_id), 'battles', {'uid':int(modal_ctx.guild_id), 'battle_list':[], 'name_list':[], 'battling': False})
        
        battle_list = db_['battle_list']
        name_list = db_['name_list']
        
        list_of_fighters = []
        decoded_fighters = []
        
        if ',' in values[0]:
            list_of_fighters = values[0].split(',')
        
        can_pass = True
        
        decoded_bcl = ''

        if len(list_of_fighters) > 0:
            for fighter in list_of_fighters:
                try:
                    encode = fighter.encode('utf-8')
                    base64_ = base64.b64decode(encode + b'==')
                    decoded_bcl = base64_.decode('utf-8')
                    decoded_fighters.append(decoded_bcl)
                except:
                    pass
        else:
            try:
                encode = values[0].encode('utf-8')
                base64_ = base64.b64decode(encode + b'==')
                decoded_bcl = base64_.decode('utf-8')
            except:
                await fancy_send(modal_ctx, f'[ Your BCL seems to be formatted incorrectly. ]', ephemeral = True, color = 0xff171d)
                return 
        
        name = decoded_bcl.split('►')[0]
        
        if name in name_list:
            await fancy_send(modal_ctx, f'Sorry, it seems as though ``{name}`` is already a fighter in this tournament!', ephemeral = True, color = 0xff171d)
            can_pass = False
        
        if can_pass:
            if len(list_of_fighters) > 0:
                
                if len(decoded_fighters) > 0:
                    for fighter in decoded_fighters:
                        name = fighter.split('►')[0]
                        if not name in name_list:
                            name_list.append(name)
                            battle_list.append(fighter)
                            
                else:
                    await fancy_send(modal_ctx, f'Could not import any fighters.', ephemeral = True, color = 0xff171d)
                    return
                
                await fancy_send(modal_ctx, f'<@{modal_ctx.author.id}> added {len(decoded_fighters)} fighters to the roster.')
                await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'battle_list', battle_list)
                await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'name_list', name_list)
            else:
                battle_list.append(decoded_bcl)
                name_list.append(name)
                await fancy_send(modal_ctx, f'<@{modal_ctx.author.id}> imported ``{name}`` to the roster.')
                
                await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'battle_list', battle_list)
                await db.SetDatabase(int(modal_ctx.guild_id), 'battles', 'name_list', name_list)
        
    @extension_component('menuBattle')
    async def delete(self, menu_modal, value):
        
        db_ = await db.GetDatabase(int(menu_modal.guild_id), 'battles', {'uid':int(menu_modal.guild_id), 'battle_list':[], 'name_list':[], 'battling': False})
        
        battle_list = db_['battle_list']
        name_list = db_['name_list']
        
        value = value[0]
        
        del battle_list[int(value)]
        name_ = name_list.pop(int(value))
        
        await fancy_send(menu_modal, f'<@{menu_modal.author.id}> removed ``{name_}`` from the roster.')
        
        await db.SetDatabase(int(menu_modal.guild_id), 'battles', 'battle_list', battle_list)
        await db.SetDatabase(int(menu_modal.guild_id), 'battles', 'name_list', name_list)
        
    @battles.error
    async def you_fucked_up_gpt_three(self, ctx : CommandContext, error):
        
        await db.SetDatabase(int(ctx.guild_id), 'battles', 'battling', False)
        
        embed = await on_error(error)
        
        await ctx.send(embeds= embed)

def setup(client):
    BATTLES(client)